#!/usr/bin/env python3
"""A Script to start the cync2mqtt app"""
import argparse
import asyncio
import functools
import logging
import os
import sys
import time
from multiprocessing import Process, Value
from pathlib import Path
from signal import SIGINT, SIGTERM, signal

import yaml

from acync import Cync2MQTT

logger = logging.getLogger('cync2mqtt')


def run_in_subprocess(args, watchtime):
    # watchtime is time.time() of when the process was called
    with Path(args.configyaml).open("rt") as fp:
        configdict = yaml.safe_load(fp)

    for quickcheck in ('mqtt_url', 'meshconfig'):
        if quickcheck not in configdict:
            logger.error("YAML config must at least define mqtt_url and meshconfig!")
            return -1

    cm = Cync2MQTT(configdict, watchtime=watchtime)
    dbg_arg = False
    if args.log_level.upper() == 'DEBUG':
        dbg_arg = True
        logger.debug("Debug mode enabled by CLI argument")

    if dbg_env := os.environ.get('DEBUG') is not None:
        dbg_env = dbg_env.strip().upper()
        _t = ('TRUE', '1', 'YES', 'Y', 'T')
        _f = ('FALSE', '0', 'NO', 'N', 'F')

        if dbg_env in _t + _f:
            if dbg_env in _t:
                dbg_arg = True
                logger.info("Debug mode enabled by DEBUG environment variable")

            elif dbg_env in _f:
                dbg_arg = False
                logger.info("Debug mode disabled by DEBUG environment variable")
        if dbg_arg is True:
            for handler in logger.handlers:
                handler.setLevel(logging.DEBUG)
            logger.setLevel(logging.DEBUG)
        elif dbg_arg is False:
            for handler in logger.handlers:
                handler.setLevel(logging.INFO)
            logger.setLevel(logging.INFO)

    # import uvloop
    # uvloop.new_event_loop().run_until_complete(cm.run_mqtt())
    asyncio.run(cm.run_mqtt(), debug=dbg_arg)


def main_signal_handler(p: Process, signum, frame):
    """Signal handler to catch SIGINT and SIGTERM and try to shutdown cleanly.
    If it fails, just kill the process."""
    timeout = 30
    logger.info("Trying clean shutdown (timeout %d)", timeout)
    os.kill(p.pid, SIGINT)
    _s = time.time()
    p.join(timeout)
    _end = time.time() - _s
    if p.exitcode is None:
        logger.error(f"Clean shutdown failed (took {_end:.5f}), killing process")
        p.kill()
    else:
        logger.info(f"Clean shutdown succeeded (took {_end:.5f})")
    sys.exit()


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("configyaml", help="YAML config file")
    parser.add_argument("--log-level", default='INFO', help='set log level', choices=['debug', 'info'])
    args = parser.parse_args()

    logfmt = logging.Formatter(
        "%(asctime)s.%(msecs)04d %(levelname)s - %(name)s %(module)s:%(lineno)d -> %(message)s",
        "%m/%d/%y %H:%M:%S",
    )
    numeric_level = getattr(logging, args.log_level.upper(), None)

    if not isinstance(numeric_level, int):
        raise ValueError('Invalid log level: %s' % args.log_level)

    # set log level, log format and add a handler to stdout
    from acync import ACYNC_LOG_NAME, C2M_LOG_NAME
    for logname in (ACYNC_LOG_NAME, C2M_LOG_NAME):
        setlogger = logging.getLogger(logname)
        setlogger.setLevel(numeric_level)
        h = logging.StreamHandler(sys.stdout)
        h.setLevel(numeric_level)
        h.setFormatter(logfmt)
        setlogger.addHandler(h)

    while True:
        watchtime = Value('Q', int(time.time()))
        p = Process(target=run_in_subprocess, args=(args, watchtime))
        p.start()

        signal(SIGTERM, functools.partial(main_signal_handler, p))
        signal(SIGINT, functools.partial(main_signal_handler, p))

        while True:
            time.sleep(60)
            # if it is currently 10 mins past the last time we checked, or the process has exited, break the loop
            if int(time.time()) > watchtime.value + 600:
                logger.debug(f"breaking out of while True loop because int(time.time()) > watchtime.value + 600 "
                             f"[10 mins since process started?]")
                break
            elif p.exitcode is not None:
                logger.debug(f"breaking out of while True loop because p.exitcode is not None")
                break
        if p.exitcode is None:
            logger.error("Notify timeout? [p.exitcode is None] - attempt restart by sending SIGINT...")
            # Send signal
            os.kill(p.pid, SIGINT)
        elif p.exitcode == -1:
            break
        _s = time.time()
        p.join(30)
        logger.debug(f"After while True loop - Join returned after {time.time() - _s:.5f} seconds")
        if p.exitcode is None:
            logger.error("Clean shutdown failed, killing process")
            p.kill()

        sleeptime = watchtime.value + 600 - int(time.time())
        if sleeptime < 10:
            sleeptime = 10
        logger.info(f"Will attempt reconnect in {sleeptime} seconds")
        time.sleep(sleeptime)
        logger.info("Restarting!")


if __name__ == "__main__":
    main()
